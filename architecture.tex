% !TEX root = ./arock_pkg_main.tex
\section{Architecture}

The toolbox can be broken into the following layers: Multicore Drivers, Kernels, Schemes, Operators, and Linear Algebra.
Each layer represents a different mathematical component. 
To maintain the mathematical abstraction between layers, Interfaces are used when necessary. 
Interfaces are a set of assumed functionality of a layer.
Layers interact through their interfaces.
Consider the Interface for the Operator object:

\begin{lstlisting}[language=C++,label={Operator_Interface}]
struct Operator_Interface {
   // returns the operator evaluated on v at the given index
   double operator() (Vector* v, int index);
  // returns the operator evaluated on v at the given index
   double operator() (double val, int index);
  //applies full operator to v_in and write it to v_out
   void operator() (Vector* v_in, Vector* v_out);
  //optional: see CFU paper
  void update_cache_vars (double old_x_i, double new_x_i, int index);
  // update the step size
   void update_step_size (double step_size_) ;
 };
\end{lstlisting}

For an object to belong to the Operator layer, it must have these functions defined.
Attempting to use an object as an Operator that does not have the functionality defined by the Operator Interface will result in compiler errors.
Note that the Operator Inteface only includes the function declarations, not the implementation of the functions themselves.
As a result, implementation is decoupled from usage.
This allows for easy maintenance and specialization of code while not affecting the user's code.

The following is a brief description of each layer and how it interacts with the layers above and below it.

\subsection{Multicore Drivers}


Consider algorithm \ref{alg:fbs_l1_log}.
 The algorithm assumes the existence of computing agents.
The Multicore Drivers  layer is responsible for the creation of agents.
The  algorithm \ref{alg:fbs_l1_log} provides a concrete recipe for creating an agent: a coordinate update scheme, a coordinate choice rule, a stepsize, and an iteration count.
At a high level, this section can be understood as a mapping from a coordinate update scheme to a multicore solver.

As seen in Section~\ref{sec:quick_start}, the \pkg~driver, takes as input a scheme object, and a parameters object.
The parameters object determines how coordinates are chosen, how many iterations to run, and the stepsize.
Coordinate choices include cyclic, block cyclic, and randomized block. 
\pkg~launches creates  worker agents, agents that interact with the solver object to produce coordinate updates, and a controller agent, an agent that manages the worker threads.
The number of worker agents is specified through the parameters object.
Agents are realized as c++11 threads.

Most users can treat the Multicore Drivers as black box functionality.
As the details of a coordinate update scheme are packaged into a scheme object, our Multicore Drivers are insulated from most common code modficiations.
In the case that a different coordinate rule or a specialization of work distribution is desired, the Multicore Driver layer must be understood at a lower level.
To understand  Multicore Drivers later at a lower level, it is necessary to know how to launch and join threads.


\subsection{Kernel}


The Multicore Drivers Layer is responsible for creating agents, and the Kernel layer contains the agents types that can be created.
A worker agent chooses an index according to its rule, and, using a scheme object, computes a coordinate update.
As such, The Kernel layer can be seen as different realizations of the while loop stucture of algorithm \ref{alg:fbs_l1_log}.
In addition, the Kernel layer contains controller agents.
A controller agent manages the worker agents by choosing stepsizes to accelerate convergence.
The current controller agent monitors convergence by maintaining an approximate fixed point residual.

Agents are realized as c++11 threads and a c++11 thread is constructed from a function.
As a result, each worker and controller type, has  a corresponding function.
If the user wishes to introduce a new agent type, they need only write a function that implements the logic of the new agent.
They must then modify the Multicore Driver layer to recognize their new agent type as an option.

\subsection{Schemes}

Objects in the Scheme Layer are used by by worker agents in the Kernel Layer to run a multicore solver.
Schemes are objects with, at minimum, member functions as defined by the Scheme Interface.
\begin{lstlisting}[language=C++]
struct Scheme_Interface {
void update_params(Params* params);
double operator() (int index);
};
\end{lstlisting}
By providing a coordinate to the scheme object, a coordinate update is applied.
The Scheme Interface is very lightweight, as schemes can be quite varied in nature.

The Scheme layer is intended to model the mathematical dvide between optimization methods and applications of optimization methods to specific problems.
 For example, equation \ref{eq:fbs_l1_log} is Forward Backward Splitting (also referred as Proximal Gradient Method) applied to a specific problem, sparse logistic regression.
 A realization of  Forward Backward Splitting is constructed by composing a specific  Forward Operator and a specific Backward Operator.
 At a high level, the scheme layer implements algorithm factories.
 We provide implemenations of the following schemes: \texttt{ForwardBackwardSplitting}, \texttt{ProximalPointAlgorithm},  \texttt{GradientDescent}, \texttt{BackwardForwardSplitting}, and \texttt{PeacemanRachfordSplitting}.

Objects in the Scheme Layer are implemented as templates.
Templates, in c++, are code factories.
 Based upon the arguments passed to the template, c++ automatically constructs a corresponding object type for the user.
For example, in code snippet \ref{fbs_l1_log_code} the scheme type of \texttt{fbs} is defined by the arguments to the forward backward splitting template, \texttt{forward\_grad\_for\_log\_loss<SpMat>}, and \texttt{prox\_l1}. 
 Different arguments to the template result in different coordinate update schemes.

A user can construct solvers by choosing a scheme, and selecting operator objects to specialize the scheme to a specific problem. 
If the provided schemes are not sufficient, the user may implement their own scheme.
The user is encouraged to use objects from the Operator Layer as building blocks, but direct implementaiton of a coordinate update scheme is allowed.

\subsection{Operators}

Operators are objects with, at minimum, member functions as defined by code snippet \ref{Operator_Interface}, the Operator Interface..
Many optimization algorithms  have computational commonalities.
For instance, all first order methods interacting with equation \ref{eq:l1_log} will need to compute the gradient of logistic regression.
The Operator layer formalizes these computatioanl commonallities by encapsulating them in Operator objects.
At a high level, the Operator Layer contains the atomic components of optimization.
In code snippet \ref{fbs_l1_log_code}, a coordinate update scheme is constructed simply by creating two Operators, and handing them to a Scheme object.
Operator objects allow the user to construct algorihtms as written on paper without worrying about implementing the low level computations themselves.

The construction of an Operator object depends upon what is necessary to compute its coordinate update efficiently.
For example, \texttt{forward\_grad\_for\_log\_loss<SpMat>} requires the matrix \texttt{A}, the vector \texttt{b}, a stepsize \texttt{eta},  and, to maintain computational efficiency, the cached variable \texttt{Atx}.
In some cases the data may be dense, sparse, or best represented by a function (consider the wavelet tranform).
Operators, to allow for different data respresentations, are templatized on their data.
The matrix \texttt{A}, in this example, is sparse.

If the user needs a specialzied version of an existing operator, they can use C++'s template specialization to implement it.
If the user needs a new operator,  the new operator can interact seamlessly with the existing toolbox as long as the Operator Interface is obeyed.





\subsection{Linear Algebra}

We use Eigen package to represent sparse matrices and vectors. 
Sparse linear algebra is provided through an interface to Eigen and Sparse BLAS.
Dense linear algebra is provided through an interface to BLAS. 







